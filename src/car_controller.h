/*
 Node: car_controller 
 Author: German Ruiz Mudarra, UMA Garage Team.
 Created: July 2020
 Last modified: March 2021

 Description:  
    
 Subscriptions:
    /adir/enable_control    (std_msgs::Bool): 
    /adir/reference         (std_msgs::point2D): 
    /odom                   (nav_msgs::Odometry): Estimated global position of the car

Publications:
    /steering               (std_msgs::UInt8): 
    /manual_control/speed   (std_msgs::Int16): Used for giving speed commands to the car
 */

#ifndef CAR_CONTROLLER_H
    #define CAR_CONTROLLER_H
    
    #include "ros/ros.h"
    #include "math.h"
    #include "iostream"
    using namespace std;

    // Import ROS message libraries
    #include "std_msgs/Int16.h"
    #include "std_msgs/UInt8.h"
    #include "std_msgs/Bool.h"
    #include "geometry_msgs/Point.h"
    #include "nav_msgs/Odometry.h"
    #include "geometry_msgs/Quaternion.h"
    #include "tf/transform_datatypes.h"
    // Import ADIR custom messages
    #include "adir/point2D.h"

    // Message queueing parameters
    static const uint32_t ODOM_QUEUE_SIZE = 1;
    static const uint32_t REFERENCE_QUEUE_SIZE = 1;
    static const uint32_t CONTROL_QUEUE_SIZE = 1;
    static const uint32_t SPEED_QUEUE_SIZE = 1;
    static const uint32_t STEERING_QUEUE_SIZE = 1;

    // Cartesian coordinates, this way points can be defined as P(x,y)
    struct position_t {
        double x;
        double y;
        // Constructor for easy mapping
        position_t(double arg_x, double arg_y) : x(arg_x), y(arg_y) {}
    };

    // Struct that 
    struct car_state_t {
        double x;
        double y;
        double theta;
        int theta_deg;
        double v; 
        double speed_state; 
    };

    // P gain of the controller
    static const double ORIENTATION_P = 500.0;

    /*
    static const double SPEED_P = 10.0;
    static const double SPEED_I = 10.0;
    static const double SPEED_REFERENCE = 0.1;
    */
   
    // Function promises
    void callbackReferenceData(const adir::point2D::ConstPtr& msg);
    void callbackOdomData(const nav_msgs::Odometry::ConstPtr& msg);
    void callbackEnableControlData(const std_msgs::Bool::ConstPtr& msg);
    
    uint8_t saturationU8(int a);
    int16_t saturation16(int a);
    void orientationControl();
    void speedControl();

    // Variables for subscribing to the reference generated by the intersection planners, odometry and node enabler
    ros::Subscriber reference_sub, odom_sub, control_sub;
    position_t reference(0,0);
    double roll, pitch, yaw;
    bool enable_orientation_control = false;
    car_state_t car;

    // Variables for publishing speed and steering values
    ros::Publisher speed_pub, steering_pub;
    std_msgs::Int16 speed_msg;
    std_msgs::UInt8 steering_msg;

    // Variables for ROS parameters
    int loop_rate;
    string odometry_topic;
    string reference_topic;
    string control_topic;
    string speed_topic;
    string steering_topic;

#endif